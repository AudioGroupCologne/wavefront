use std::f32::consts::PI;

use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy_pixel_buffer::prelude::*;

use colorgrad::Color;

const SIMULATION_WIDTH: u32 = 500;
const SIMULATION_HEIGHT: u32 = 500;
const PIXEL_SIZE: u32 = 1;
const NUM_INDEX: u32 = 9; //cur_bottom cur_left cur_top cur_right next_bottom next_left next_top next_right pressure
const WALL_FAC: f32 = 1.;
const BOUNDARY_FAC: f32 = -0.171573;

fn main() {
    let size: PixelBufferSize = PixelBufferSize {
        size: UVec2::new(SIMULATION_WIDTH, SIMULATION_HEIGHT),
        pixel_size: UVec2::new(PIXEL_SIZE, PIXEL_SIZE),
    };

    let mut grid = Grid {
        cells: vec![0.; (SIMULATION_WIDTH * SIMULATION_HEIGHT * NUM_INDEX) as usize],
        boundaries: Boundary {
            bottom: vec![],
            left: vec![],
            top: vec![],
            right: vec![],
        },
    };

    // Boundaries
    // TOP
    for x in 0..SIMULATION_WIDTH {
        grid.boundaries.top.push(array_pos(x, 0, 0))
    }
    // BOTTOM
    for x in 0..SIMULATION_WIDTH {
        grid.boundaries
            .bottom
            .push(array_pos(x, SIMULATION_HEIGHT - 1, 0))
    }
    // LEFT
    for y in 0..SIMULATION_HEIGHT {
        grid.boundaries.left.push(array_pos(0, y, 0))
    }
    // RIGHT
    for y in 0..SIMULATION_HEIGHT {
        grid.boundaries
            .right
            .push(array_pos(SIMULATION_WIDTH - 1, y, 0))
    }

    let gradient = GradientResource(
        colorgrad::CustomGradient::new()
            .colors(&[
                Color::from_rgba8(250, 172, 168, 255),
                Color::from_rgba8(0, 0, 0, 255),
                Color::from_rgba8(221, 214, 243, 255),
            ])
            .domain(&[-2.0, 2.0])
            .build()
            .unwrap(),
    );

    App::new()
        .add_plugins((DefaultPlugins, PixelBufferPlugin))
        .insert_resource(grid)
        .insert_resource(gradient)
        .add_systems(Startup, (pixel_buffer_setup(size), spawn_initial_sources))
        .add_systems(Update, (bevy::window::close_on_esc, mouse_button_input))
        .add_systems(
            Update,
            (
                (calc_system, apply_system, update_system).chain(),
                draw_pixels,
            ),
        )
        .run();
}

fn spawn_initial_sources(mut commands: Commands) {
    commands.spawn(Source::new(
        array_pos(SIMULATION_WIDTH / 2, SIMULATION_WIDTH / 2, 0),
        10.,
        0.0,
        1.0,
        SourceType::Sin,
    ));
    commands.spawn(Source::new(
        array_pos(SIMULATION_WIDTH / 4, SIMULATION_WIDTH / 4, 0),
        10.,
        1.0,
        1.0,
        SourceType::Sin,
    ));
}

#[derive(Resource)]
struct GradientResource(colorgrad::Gradient);

// TLM Logic
#[derive(Component)]
struct Drag;

#[derive(Debug, Resource)]
struct Grid {
    /// full grid: [cur_bottom, cur_left, cur_top, cur_right, next_bottom, next_left, next_top, next_right, pressure]
    cells: Vec<f32>,
    /// A list of boundary nodes
    boundaries: Boundary,
}

#[derive(Debug, Default, Component)]
struct Source {
    /// index of the cell in the grid
    index: usize,
    /// phase shift of the function (currently in seconds)
    phase: f32,
    /// frequency of the function (in Hz)
    frequency: f32,
    /// amplitude of the function (currently unitless)
    amplitude: f32,
    /// type of the source
    r#type: SourceType,
}

#[derive(Debug, Default)]
struct Boundary {
    //Leo Smallvec und so
    /// indecies of bottom boundary nodes
    bottom: Vec<usize>,
    /// indecies of left boundary nodes
    left: Vec<usize>,
    /// indecies of top boundary nodes
    top: Vec<usize>,
    /// indecies of right boundary nodes
    right: Vec<usize>,
}

#[derive(Debug, Component)]
struct Wall(usize);

#[derive(Debug, Default)]
enum SourceType {
    #[default]
    Sin,
    Gauss,
}

impl Source {
    fn new(index: usize, amplitude: f32, phase: f32, frequency: f32, r#type: SourceType) -> Self {
        Self {
            index,
            phase,
            frequency,
            amplitude,
            r#type,
        }
    }
}

/// generated by chat gpt, not sure if it's correct
fn periodic_gaussian(x: f32, period: f32, amplitude: f32, mean: f32, variance: f32) -> f32 {
    // Ensure x is within the periodic domain [0, period)
    let x = (x % period + period) % period;

    // Calculate the Gaussian function value
    let exp_term = (-0.5 * ((x - mean) / variance).powi(2)).exp();
    let scaling_factor = 1.0 / (variance * (2.0 * PI).sqrt());

    amplitude * scaling_factor * exp_term
}

impl Grid {
    fn update(&mut self) {
        //TODO: parallelize?
        for i in 0..SIMULATION_WIDTH * SIMULATION_HEIGHT {
            let array_pos: usize = (i * NUM_INDEX) as usize;

            self.cells[array_pos] = self.cells[array_pos + 4];
            self.cells[array_pos + 1] = self.cells[array_pos + 5];
            self.cells[array_pos + 2] = self.cells[array_pos + 6];
            self.cells[array_pos + 3] = self.cells[array_pos + 7];

            //calculate pressure
            self.cells[array_pos + 8] = 0.5
                * (self.cells[array_pos]
                    + self.cells[array_pos + 1]
                    + self.cells[array_pos + 2]
                    + self.cells[array_pos + 3]);
        }
    }

    fn calc(&mut self) {
        //TODO: parallelize?
        for x in 1..SIMULATION_WIDTH - 1 {
            for y in 1..SIMULATION_HEIGHT - 1 {
                self.calc_cell(
                    array_pos(x, y, 0),
                    self.cells[array_pos(x, y + 1, 2)],
                    self.cells[array_pos(x - 1, y, 3)],
                    self.cells[array_pos(x, y - 1, 0)],
                    self.cells[array_pos(x + 1, y, 1)],
                );
            }
        }
    }

    fn calc_cell(
        &mut self,
        coord_one_d: usize,
        bottom_top: f32,
        left_right: f32,
        top_bottom: f32,
        right_left: f32,
    ) {
        self.cells[coord_one_d + 4] = 0.5 * (-bottom_top + left_right + top_bottom + right_left);
        self.cells[coord_one_d + 5] = 0.5 * (bottom_top - left_right + top_bottom + right_left);
        self.cells[coord_one_d + 6] = 0.5 * (bottom_top + left_right - top_bottom + right_left);
        self.cells[coord_one_d + 7] = 0.5 * (bottom_top + left_right + top_bottom - right_left);
    }

    fn apply_sources(&mut self, time: f32, sources: &Query<&Source>) {
        for source in sources.iter() {
            //? maybe needs to be optimized
            let calc = match source.r#type {
                SourceType::Sin => {
                    source.amplitude * (2. * PI * source.frequency * (time - source.phase)).sin()
                }
                SourceType::Gauss => {
                    periodic_gaussian(time, source.frequency, source.amplitude, 5., 1.)
                }
            };

            self.cells[source.index + 4] = calc;
            self.cells[source.index + 5] = calc;
            self.cells[source.index + 6] = calc;
            self.cells[source.index + 7] = calc;
        }
    }

    fn apply_walls(&mut self, walls: &Query<&Wall>) {
        for wall in walls.iter() {
            let (x, y) = array_pos_rev(wall.0 as u32);
            self.cells[wall.0 + 4] = WALL_FAC * self.cells[array_pos(x, y + 1, 2)];
            self.cells[wall.0 + 5] = WALL_FAC * self.cells[array_pos(x - 1, y, 3)];
            self.cells[wall.0 + 6] = WALL_FAC * self.cells[array_pos(x, y - 1, 0)];
            self.cells[wall.0 + 7] = WALL_FAC * self.cells[array_pos(x + 1, y, 1)];
        }
    }

    fn apply_boundaries(&mut self) {
        //pls math check
        for &boundary_index in self.boundaries.bottom.iter() {
            self.cells[boundary_index + 6] =
                BOUNDARY_FAC * self.cells[boundary_index - (NUM_INDEX * SIMULATION_WIDTH) as usize];
        }
        for &boundary_index in self.boundaries.left.iter() {
            self.cells[boundary_index + 7] =
                BOUNDARY_FAC * self.cells[boundary_index + NUM_INDEX as usize + 1];
        }
        for &boundary_index in self.boundaries.top.iter() {
            self.cells[boundary_index + 4] = BOUNDARY_FAC
                * self.cells[boundary_index + (NUM_INDEX * SIMULATION_WIDTH) as usize + 2];
        }
        for &boundary_index in self.boundaries.right.iter() {
            self.cells[boundary_index + 5] =
                BOUNDARY_FAC * self.cells[boundary_index - NUM_INDEX as usize + 3];
        }
    }
}

fn array_pos(x: u32, y: u32, index: u32) -> usize {
    (y * SIMULATION_WIDTH * NUM_INDEX + x * NUM_INDEX + index) as usize
}

fn array_pos_rev(i: u32) -> (u32, u32) {
    let x = (i / 9) % SIMULATION_WIDTH;
    let y = i / 9 / SIMULATION_WIDTH;
    (x, y)
}

// systems

fn calc_system(mut grid: ResMut<Grid>) {
    grid.calc();
}

fn apply_system(
    mut grid: ResMut<Grid>,
    time: Res<Time>,
    sources: Query<&Source>,
    walls: Query<&Wall>,
) {
    grid.apply_sources(time.elapsed_seconds(), &sources);
    grid.apply_walls(&walls);
    grid.apply_boundaries();
}

fn update_system(mut grid: ResMut<Grid>) {
    grid.update();
}

fn draw_pixels(
    mut pb: QueryPixelBuffer,
    grid: Res<Grid>,
    gradient: Res<GradientResource>,
    walls: Query<&Wall>,
) {
    let mut frame = pb.frame();
    frame.per_pixel_par(|coords, _| {
        let p = grid.cells[array_pos(coords.x, coords.y, 8)];
        let color = gradient.0.at((p) as f64);
        Pixel {
            r: (color.r * 255.) as u8,
            g: (color.g * 255.) as u8,
            b: (color.b * 255.) as u8,
            a: 255,
        }
    });
    // Walls
    for wall in walls.iter() {
        let (x, y) = array_pos_rev(wall.0 as u32);
        //TODO: handle result
        let _ = frame.set(
            UVec2::new(x, y),
            Pixel {
                r: 255,
                g: 255,
                b: 255,
                a: 255,
            },
        );
    }
}

//User Input

fn screen_to_grid(x: f32, y: f32, screen_width: f32, screen_height: f32) -> Option<(u32, u32)> {
    let x = (x - (screen_width - (SIMULATION_WIDTH / PIXEL_SIZE) as f32) / 2.) as u32;
    let y = (y - (screen_height - (SIMULATION_HEIGHT / PIXEL_SIZE) as f32) / 2.) as u32;

    if x >= SIMULATION_WIDTH || y >= SIMULATION_HEIGHT {
        return None;
    }

    Some((x, y))
}

fn mouse_button_input(
    buttons: Res<Input<MouseButton>>,
    q_windows: Query<&Window, With<PrimaryWindow>>,
    sources: Query<(Entity, &Source), Without<Drag>>,
    mut drag_sources: Query<(Entity, &mut Source), With<Drag>>,
    mut commands: Commands,
) {
    if buttons.just_pressed(MouseButton::Left) {
        let window = q_windows.single();
        if let Some(position) = window.cursor_position() {
            if let Some((x, y)) =
                screen_to_grid(position.x, position.y, window.width(), window.height())
            {
                // grid.sources.push(Source::new(
                //     array_pos(x, y, 0),
                //     10.,
                //     0.0,
                //     1.0,
                //     SourceType::Sin,
                // ));
                for (entity, source) in sources.iter() {
                    let (s_x, s_y) = array_pos_rev(source.index as u32);
                    if s_x.abs_diff(x) <= 10 && s_y.abs_diff(y) <= 10 {
                        commands.entity(entity).insert(Drag);
                    }
                }
            }
        }
    }
    if buttons.just_released(MouseButton::Left) {
        drag_sources.iter_mut().for_each(|(entity, _)| {
            commands.entity(entity).remove::<Drag>();
        });
    }
    if buttons.pressed(MouseButton::Left) && drag_sources.iter_mut().count() >= 1 {
        let window = q_windows.single();
        if let Some(position) = window.cursor_position() {
            if let Some((x, y)) =
                screen_to_grid(position.x, position.y, window.width(), window.height())
            {
                drag_sources.iter_mut().for_each(|(_, mut source)| {
                    source.index = array_pos(x, y, 0);
                });
            }
        }
    }
    if buttons.pressed(MouseButton::Right) {
        let window = q_windows.single();
        if let Some(position) = window.cursor_position() {
            if let Some((x, y)) =
                screen_to_grid(position.x, position.y, window.width(), window.height())
            {
                //TODO: because of the brush size, the indices may be out of bounds
                //TODO: make bush size variable
                commands.spawn(Wall(array_pos(x, y, 0)));
                commands.spawn(Wall(array_pos(x + 1, y, 0)));
                commands.spawn(Wall(array_pos(x - 1, y, 0)));
                commands.spawn(Wall(array_pos(x, y + 1, 0)));
                commands.spawn(Wall(array_pos(x + 1, y + 1, 0)));
                commands.spawn(Wall(array_pos(x, y - 1, 0)));
                commands.spawn(Wall(array_pos(x - 1, y - 1, 0)));
                commands.spawn(Wall(array_pos(x + 1, y - 1, 0)));
                commands.spawn(Wall(array_pos(x - 1, y + 1, 0)));
            }
        }
    }
    // we can check multiple at once with `.any_*`
    if buttons.any_just_pressed([MouseButton::Left, MouseButton::Right]) {
        // Either the left or the right button was just pressed
    }
}
